<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>6 Ripping sidtunes</TITLE>
<META NAME="description" CONTENT="6 Ripping sidtunes">
<META NAME="keywords" CONTENT="sidplay">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
</HEAD>
<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0030E0" VLINK="#001870">
 <A NAME="tex2html137" HREF="node8.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./next_motif.gif"></A> <A NAME="tex2html135" HREF="sidplay.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./up_motif.gif"></A> <A NAME="tex2html129" HREF="node6.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./previous_motif.gif"></A> <A NAME="tex2html139" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html138" HREF="node8.html">7 Acknowledgements and greetings</A>
<B>Up:</B> <A NAME="tex2html136" HREF="http://www.geocities.com/SiliconValley/Lakes/5147/index.html">SIDPLAY Home Page</A>
<B> Previous:</B> <A NAME="tex2html130" HREF="node6.html">5 Technical information</A>
<BR> <P>
<H1><A NAME="SECTION00700000000000000000">6 Ripping sidtunes</A></H1>
<P>
<A NAME="ripguide">&#160;</A>
<P>
Ripping music is the process of detaching the code and data of a music player
from an enclosing program and getting the isolated music to play.
<P>
This section is not meant as a full guide on ripping C64 musics. Individual
pieces of music may be very difficult and time consuming to rip for a
beginner. And there must clearly be distinguished between <em>just a rip</em>
and a so-called <B>clean rip</B>.
In this and subsequent paragraphs the term <B>ripper</B>
refers to a human person, unless specified in any other way.
<P>
<H1><A NAME="SECTION00710000000000000000">6.1 Clean rips</A></H1>
<P>
Ripping can be as easy as having to determine two single program addresses
only and saving a small region of enclosing memory.
<P>
Clean rips often are much harder to achieve, as their aim is to strip down
the source program to nothing else than the music player and its belonging
data, thereby making the ripped data as short as possible. Additionally,
rippers often copy the remaining fragments of data into a more compact form.
Sometimes they even relocate the player. This may be required if one wants to
merge all subsongs (perhaps each with a separate player), keeping in mind the
C64 memory limitation of 64 kB. Concerning SIDPLAY this is easier, as the 
entire data is reloaded upon starting each subsong, permitting the ripper to
always use the full memory regardless of whether he likes to overwrite unused
parts of the music data or not. The entire sidtune data will be recovered upon
restarting a song or starting another song.
<P>
Cases where the player and its data (including all subsongs) are spread
throughout the whole memory are crucial. It is then difficult to determine
whether certain regions of memory actually belong to the music player.
Proving the integrity of a fragmented song can only be done by listening
to it and comparing it to its original program. This might be the most
boring part upon performing a rip if you don't want to fully read and
analyze the music player (which, by the way, would be the only true way
to track down the location of all belonging data; except using a self-written
utility). Consider a long song, where you would have to listen to it entirely
to find its end to be broken. The effect of only a bit of data missing might
not be as obvious as you would guess. A single instrument might be only
slightly altered. You probably would not even notice a difference, a weaker
vibrato effect for instance. Better save a wider region of the memory rather
than cutting off any parts by accident.
<P>
Consider some of the required music data (such as vibrato tables, instrument
definitions or track and pattern data) to be put into a memory region, which you
would not even think of. For instance, sensitive data might have been put into
the stack address space or into the zero-page. Zero-page pointers sometimes are
only initialized once by some code at the early start of the program. It can
be required to write an own music player initialization, most often based on
available code fragments.
<P>
Usually only musics in demonstration programs are likely to be protected.
Hard to rip musics in games generally are protected by accident, which
either means the game programmer mixed parts of the music player code with
his own code (or he did the music himself) or he had a very confusing coding
style (socalled <B>spaghetti-code</B>), making the code unnecessarily
difficult to understand and making it almost impossible to detach music
player code from program code. More on this further below.
<P>
As long as a (partially) ripped music can be determined to be oviously
damaged, you can still decide to leave it in its most basic form. For
instance, if the code of the application and the music player code are
nested, saving the entire memory might be a hint. Making the rip a clean
rip is just an optimization and could be done later.
<P>
<H1><A NAME="SECTION00720000000000000000">6.2 Requirements</A></H1>
<P>
The availability of special software or external hardware tools is of much
help. Try to get one of the following (sorted by recommended priority):
<UL>
<LI> Any hardware modul with monitoring functions: Memory dump, search, fill, 
  disassembler, assembler, load and save of any memory region, ability to restore
  the screen buffer and the stack.
<LI> A hardware freezer cardridge for the C64 expansion port. For instance,
  this will enable you to freeze the running program at any point you like. This
  is especially helpful, since it's giving the possibility to repeatedly access a
  song at the end of a game or demo without having to run the program from the
  very beginning.
<LI> A self-made EPROM module, which provides at least a subset of the
  monitoring functions listed above.
<LI> A software <B>monitor</B>, which provides any of the above functions;
  usually sufficient enough to take a close look at those parts of memory, which
  remain unmodified after a hardware reset.
<LI> A <B>ripping utility</B>. This chapter does not cover any of these.
<LI> A utility, that can read/write C64 disks with the C64 floppy drive
  connected to your PC. Or a utility that can transfer data via a serial
  cable from the C64 to a different platform.
</UL>
<P>
If you don't have access to any of the tools listed above, you are definitely
out of luck. At least I can't think of any other equivalent tools. Except
nowadays you do not need a real C64 for ripping music. Some of the existing
C64 emulators provide a built-in emulation of such monitoring and freezing
functions, e.g. the freely available C64 emulator <B>VICE</B><A NAME="tex2html5" HREF="footnode.html#256"><IMG  ALIGN=BOTTOM ALT="gif" SRC="./foot_motif.gif"></A>.
As a side note, it is also possible to rip directly from *.D64 emulator disk
images.
<P>
Of course you need to know of the capabilities of your tools and how to use
them efficiently. Finally, you certainly need to know the C64's hardware and
the 6502/6510 machine language. A bit of knowledge of hexadecimal machine codes
would be appreciated, but is rarely necessary as you will almost never
have to read plain hex machine code. You don't need to be a programmer either,
though you should be able to read and understand (and thus be able to follow)
disassemblings.
<P>
<H1><A NAME="SECTION00730000000000000000">6.3 A quick guide on ripping</A></H1>
<P>
The method presented here is just <B>one</B> way to rip a sidtune. It may not be
directly applicable to all sidtunes and their programs. It is more meant as an
introduction. The overall ability to rip a specific sidtune mainly depends on
experience and instinct, as well as a bit of machine code programming skills.
You will certainly build your own individual ripping algorithm based upon the
experiences you will make. Most of the examples and recommendations in this
section are based upon questions I and others on Usenet were asked. For the
weird case, that you want to test this guide on some program, please take into
account that intro/demo tunes generally are much more easy to rip than game
tunes. If you want to rip a very easy game tune, check out the game <em>Commando</em>.
It is probably the most famous tune and very easy to rip due to the simplicity
of <em>Rob Hubbard</em>'s modularized music player.
<P>
Have you ever tried to rip a sidtune from a game or demo? Maybe you always
wanted to be able to listen to your favourite one without having to load and
run a larger program? If you ever tried to rip, did you succeed? If not, what
was the main problem? Maybe you didn't know where to start? Maybe you erratically
browsed through hundreds of lines of machine code and randomly displayed kilobytes
of C64 memory without a clue? Or maybe you did not even come that far?
<P>
Depending on the tools which aid you on your ripping-task, make a hardware
reset to stop the running program and start the monitor (here the term
<B>monitor</B> always refers to the monitoring utility and not the screen :).
Making a reset does <em>not</em> mean turning off the computer and then on
again. By doing that you erase its memory! Inside a C64 emulator you often
have the choice between soft and hard reset. Soft reset should be the
recommended one unless the application is protected against resetting.
Without an expansion module the easiest way to reset the C64 is to connect
pins 1+3 (GND and RESET) of the user port (starting to count the pins from
the left while looking at the back of the C64) for a short time. For the case
that you don't have an external hardware module installed and need to load
and start a software monitor, you will overwrite a part of the memory by
loading the monitor. Some monitors are relocatable. Make and save a couple
of versions for different memory regions, e.g. <TT>$1000</TT>, <TT>$6000</TT>
and <TT>$C000</TT>. Unless you find out a memory region that is definitely not
used by the music player and data, you will likely have to repeat this
procedure:
<OL>
<LI> optionally clear the whole C64 memory by filling every RAM address with a zero
  (if the program moves memory blocks, the zeroes can serve as a visible hint on
  unused memory areas)
<LI> load and start the program containing music
<LI> make a hardware reset
<LI> (load and) start your monitor
</OL>
<P>
You already had come so far, but didn't know any further? Did you think about the
simple fact that SID music can only be produced by machine code that accesses the
SID chip? Hence that is the most trivial hint. The following steps in trying
to rip the tune will be:
<OL>
<LI> search for machine code that writes values into the SID chip registers
<LI> determine the part of the program where most of the SID accessing code 
  is stored (most likely the music player or sound fx driver)
<LI> search the whole memory for code branching to the music player area
<LI> determine the main subroutines of the music player (most common as the 
  <em>Init</em> and <em>Play</em> addresses)
</OL>
<P>
Unless the ROM and the I/O address space are turned off, the SID chip registers
are found at a constant place in memory, i.e. address <TT>$D400</TT> to (and including) <TT>$D41D</TT>.
On the contrary, all subsequent chunks of 32-bytes from <TT>$D420</TT> to <TT>$D800</TT> are mapped to
the SID chip, too. But only a very few tunes access the SID chip via these mirrored registers.
<P>
So, first we need to find the music player code. We assume the music player uses the <em>absolute</em>
addressing mode to access at least one SID register. This is most common, but must not be true for
a specific player. Basically, you could search for the appearance of any valid SID address. But
starting with the <em>Master Volume and Filter Type Register</em> <TT>$D418</TT> next to the 
<em>Oscillator 1 Control Register</em> <TT>$D404</TT> is a good hint. In your monitor enter something
like the following at the prompt to search the C64 memory for the appearance of each value:
<P>
<PRE>    &gt; H 0800 D000 18,D4</PRE>
<P>
This searches the memory from address <TT>$0800</TT> to <TT>$d000</TT> (where the VIC chip starts) for
appearance of the consecutive bytes <TT>$18</TT> and <TT>$D4</TT>. Notice the little-endian order of the
low and high byte of the 16-bit address word. Please also take into account, that if you want to
search other parts of the C64 memory, like the RAM under the ROM <TT>$d000</TT> - <TT>$FFFF</TT>, you
first have to enable/disable the desired memory bank. Further, superior monitoring tools are able
to search for full valid machine code instructions instead of just hex values. Consider the
following output:
<P>
<PRE>    &gt; H 0800 D000 18,D4
    087C 127A 15F4 CFEA 
    &gt;
    &gt; H 0800 D000 04,D4
    117A 1208 13F8 1410 15FE</PRE>
<P>
Searching for alternate <TT>$D4??</TT> values would probably also hit the area at <TT>$1???</TT>.
Avoid searching for the SID registers of operator 2+3, as most players access these via indices
and the SID base address <TT>$D400</TT>. Since repeatedly searching the C64 memory takes some time,
you can narrow down the region once you had a couple of hits. In this example there is most likely
some SID sound code between <TT>$1000</TT> and <TT>$1800</TT>. Examining the code in that area
might be enough. Keep in mind, that unless you are able to directly search for full valid
machine instructions, these hits might only be binary data. Manually searching for possible
instructions could be a hint. Consider the instruction <TT>STA $D418</TT>:
<P>
<PRE>    &gt; H 1000 2000 8D,18,D4
    1279 15F3</PRE>
<P>
Further keep in mind, that there might be more than one player in memory as well as additional
SID code outside a compact music player, so you might find your searches to hit two completely
distinct memory regions.
<P>
Next the often more difficult task of finding the initialization and play addresses of the music
player, although the overall procedure is similar:
<UL>
<LI> search for the appearance of interrupt vector <TT>$0314</TT>/<TT>$0315</TT> or vector
<TT>$FFFE</TT> <BR> 
/<TT>$FFFF</TT> and their set-up routines; then follow the interrupt handler to find a
call into the music player area; likely to be the official player entry
<LI> track down a decompressor on the stack for the starting address of the program; then
follow the code to find a call of a subroutine in the music player area; likely to be the official
initialization entry; search the whole program for the number and range of parameters used to
initialize the different subsongs or sound effects
<LI> search for the use of ROM-kernal subroutines (as CLR-screen) and hardware initialization
code; likely at the start of the program; follow it to see what the original code does
</UL>
<P>
Special problems need special treatment:
<UL>
<LI> no initialization subroutine available: reset as early as possible or try to write
an own one; determine dynamic pointers and indices, which are increased during playback
<LI> music code and data start inside screen memory <TT>$0400</TT> and no hardware module available:
insert code into the program to save the data to disk after it was moved into the screen memory;
insert code into the program to not let the program move the data, but terminate (reset)
<LI> multiple init/play addresses
<LI> separate music players
<LI> separate init functions for each subsong
</UL>
<P>
An universal C64 <em>Timer Interrupt Handler</em> at address <TT>$6000</TT> is set up like this and can
be used to verify the found play and init addresses of a rip:
<PRE>    $6000 SEI
    $6001 LDA #$60
    $6003 STA $0315
    $6006 LDA #$31
    $6008 STA $0314
    $600B LDA #$00
    $600D STA $DC0E
    $6010 LDA #$4D
    $6012 STA $DC05
    $6015 LDA #$00
    $6017 STA $DC04
    $601A LDA #$01
    $601C STA $DC0E
    $601F LDA #$0F
    $6021 STA $D418
    $6024 LDA #$35
    $6026 STA $01
    $6028 JSR &lt;INIT&gt;
    $602B LDA #$37
    $602D STA $01
    $602F CLI
    $6030 RTS
    $6031 LDA #$35
    $6033 STA $01
    $6035 JSR &lt;PLAY&gt;
    $6038 LDA #$37
    $603A STA $01
    $603C JMP $EA31</PRE>
<P>
Finally, you <em>just</em> need to save the tune to disk. Worth knowing is, that the music data may
either be stored in front of or behind the player. Or it is stored at a more distant location. The
safest way to search for the true location of the data is to follow the initialization subroutine
and try to determine where pointers, arrays, note tables and such are kept. But generally it is
enough to do a quick memory dump of the full player environment, searching for boundaries, which
often consist out of a larger number of zero padded bytes. With a bit of experience you will be
able to hit the right region just by looking at a hex dump.
<P>
<H1><A NAME="SECTION00740000000000000000">6.4 Bank switching</A></H1>
<P>
Without bank-switching it is nearly impossible for an emulator to determine which memory region
should be accessed. There are some sidtunes that do not only use the memory under the address
space of the Basic-ROM and Kernal-ROM, but also the memory under the I/O address space. To have all
sidtunes in a unique format, it would be preferred to use <em>valid</em> machine code, which would also
run on a real C64, except for the PlaySID-compatible sample-player modifications of course.
<P>
<B>Please don't neglect bank-switching</B>! It doesn't make the code of a ripped sidtune much
longer. Where necessary, it generally takes only 2*12 bytes of additional code in front of the
initialization and main player routines.
<P>
SIDPLAY's built-in machine code interpreter provides default bank settings for the C64 music
player starting addresses:
<UL>
<LI> <TT>$0000 to $9FFF -&gt; $01 = #$07</TT>
<LI> <TT>$A000 to $CFFF -&gt; $01 = #$06</TT>
<LI> <TT>$D000 to $DFFF -&gt; $01 = #$00</TT>
<LI> <TT>$E000 to $FFFF -&gt; $01 = #$05</TT>
</UL>
<P>
The main aim of these default values is to provide a sane initial state prior to executing the
music player machine code. Further, these defaults make it possible to jump directly from SIDPLAY
to any RAM area without turning off too many components. The single value <TT>$05</TT> is not
used for all the memory banks because, for instance, it would be necessary to turn back on the
Kernal area to use the end-of-irq functions.
<P>
The quickest way to add C64 bank-switching code to a sidtune is to append the following code and
adjust the <em>initialization</em> and <em>player</em> address accordingly. This example switches off
Basic-ROM and Kernal-ROM, but leaves on the I/O address space:
<P>
New &lt;init&gt;/&lt;play&gt; subroutine:
<PRE>    LDX #$35
    STX $01
    JSR &lt;init&gt;/&lt;play&gt;
    LDX #$37
    STX $01
    RTS</PRE>
<P>
Note: Keep in mind, that some <em>PlaySID-specific</em> rips assume all registers to contain a zero
prior to executing the <em>player</em> subroutine (and the X and Y-Register to contain a zero prior to
executing the <em>init</em> subroutine). Thus, when modifying those rips to use bank-switching, the
additional code does not satisfy the PlaySID-specific assumption. To satisfy such a rip,
add <TT>LDX #$00, LDY #$00</TT> in front of the music player call.
<P>
<H1><A NAME="SECTION00750000000000000000">6.5 Variable playing speed</A></H1>
<P>
Variable replaying-speed for a song can be set up via CIA 1 Timer A:
<UL>
<LI> Upon song initialization or during playback set up the CIA timer speed
via the I/O registers <TT>$DC04/$DC05</TT>.
<LI> Configure the sidtune info file (or header) to enable timer speed
support. On how to do that refer to the documentation on file formats.
</UL>
Consult your C64 programmers reference book for additional information.
The clock speed of a PAL C64 is 985248 Hz. The CIA 1 Timer A value is
calculated with this formulae:
<PRE>       985248 Hz
    ---------------- = timer_value
    song_speed in Hz

    Normal double-speed:
    985248 Hz / 100 Hz = $267C</PRE>
<P>
Some music composers demand subsequent player calls to be done after
a specific number of scan-lines. This way effect updates are affected
and, according to the composers, result in better sound.
<P>
Without the availability of emulation of scan-line interrupts you can
nevertheless achieve such a timing by dynamically updating the timer
speed for each player call. You can divide the normal speed timer value
into small chunks that would equal the system time for one scan-line:
<P>
On a PAL system:
<PRE>    $4CF8 (50 Hz) / 312 scan-lines = 63 cycles per scan-line
    63 * X scan-lines = timer value for one particular
                        player call</PRE>
<P>
<H2><A NAME="SECTION00751000000000000000">6.5.1 Normal double speed example</A></H2>
<P>
New &lt;init&gt; subroutine:
<PRE>    LDX #$26                ; plain 100 Hz
    LDY #$7C
    STX $DC05
    STY $DC04
    JMP &lt;init&gt;</PRE>
<P>
<H2><A NAME="SECTION00752000000000000000">6.5.2 Timed double speed example</A></H2>
<P>
New &lt;play&gt; subroutine for double-speed and $48 scan-lines delay:
<PRE>    LDA &lt;counter&gt;           ; decide which timer value to set
    AND #$01                ; 0=1st or 1=2nd player call
    ASL                     ; two bytes per timer value
    TAX
    LDA &lt;timer_table&gt;,X     ; $11D4 (duration of $48 scan-lines)
    STA $DC05               ; $3B24 (the rest of the screen)
    LDA &lt;timer_table+1&gt;,X   ; ($11D4 + $3B24 = $4CF8 full screen)
    STA $DC04
    INC &lt;counter&gt;
    JMP &lt;play&gt;/&lt;play2&gt;      ; maybe call different player entries</PRE>
<P>
<H1><A NAME="SECTION00760000000000000000">6.6 Interrupts</A></H1>
<P>
A lot of C64 music players contain a built-in instance of an interrupt handler and a corresponding
interrupt set-up routine. It was probably used to provide a small test player, making it able
to quickly start the music for demonstration purposes. And it often serves as an example of
what is required to correctly initialize a song, its speed and where the music player has to be
called to produce continous music. A certain simplicity of such a built-in handler provided, it is
very easy to convert such a sidtune to SIDPLAY compatible form. Specifying the play address
<TT>$0000</TT> makes SIDPLAY search and use an installed interrupt vector in either
<TT>$0314/$0315</TT> or <TT>$FFFE/$FFFF</TT>.
<P>
<H1><A NAME="SECTION00770000000000000000">6.7 ROM routines</A></H1>
<P>
Avoid any usage of Basic-ROM or Kernal-ROM routines. Not necessarily because SIDPLAY does not
include the original ROM images and does not otherwise emulate any ROM routines, but because ROM
functions generally imply any sort of I/O usage. A jump into the ROM memory is considered equal to
an <B><TT>``RTS''</B></TT> instruction. Some specific versions may include faked emulation
of a few often used and interrupt related ROM routines. If you don't want to break the
compatibility to other SID emulators, don't use these routines either.
<P>
<H1><A NAME="SECTION00780000000000000000">6.8 Converting sample players</A></H1>
<P>
Some C64 musics replay 4-bit (or 3-bit) samples by rapidly changing the SID master volume value 
<TT>$D418</TT>. This method was called <B>volume samples</B> and <B>fake samples</B>. Usually, such
a music player used a <em>Non-Maskable-Interrupt</em> (NMI, vectors <TT>$0318/19</TT> or <TT>$FFFA/FB</TT>)
next to the standard player subroutine to continually copy sample values to the master volume
register.
<P>
PlaySID introduced a different method, which required a modification of the sample players to
use a set of new SID registers, called the <B>Extended Sound Interface Device</B>. SIDPLAY provides
compatibility to these registers. Basically, the main aim of these new registers was to aid
PlaySID in directly replaying the C64 samples via one of the Amiga audio channels. The
original description of the new registers can be found in the PlaySID package or in the chapter
<em>Technical Information</em>. Using the extended registers is not as flexible as a full-featured
interrupt emulation would be, but it allows a sample playblack at maximum quality (4-bit samples :).
This section only deals with setting up an examplary sample player for SIDPLAY or PlaySID.
If you want more examples, consult the already converted sidtunes.
<P>
Modify the sample player to do the following only once for each sampled waveform you want to start
instead of continually piping sample values into the master volume register in a loop or via an
interrupt handler:
<OL>
<LI> Set the average master volume in <TT>$D418</TT>. This is usually around <TT>$08</TT> for 4-bit
sample players.
<LI> Set the sample replaying frequency in <TT>$D45D/$D45E</TT> in number of cycles. This is usually
the NMI refresh speed of the sample player, e.g. the CIA 1 Timer A value in <TT>$DC04/$DC05</TT>.
<LI> Set the sample data start address in <TT>$D41E/$D41F</TT>.
<LI> Set the sample data end address in <TT>$D43D/$D43E</TT>.
<LI> Set the sample data repeat address in <TT>$D47E/$D47F</TT>.
<LI> Set the number of repeats in <TT>$D43F</TT>: <TT>$00</TT> = none, <TT>$FF</TT> = endless,
<TT>$01</TT> - <TT>$FE</TT> = else.
<LI> Set the octave in <TT>$D45F</TT>: <TT>$00</TT> = 1st, <TT>$01</TT> = 2nd, and so on.
<LI> Set the sample order in <TT>$D47D</TT>: <TT>$00</TT> = low-nibble/high-nibble (the most common),
<TT>$01</TT> = high-nibble/low-nibble.
<LI> Enable sample replay in <TT>$D41D</TT>: <TT>$FF</TT> = 4-bit samples, <TT>$FE</TT> = 3-bit samples,
<TT>$FC</TT> = 2-bit samples. This depends on what range of values originally was written to the
master volume register.
<LI> Disable sample replay with <TT>$D41D</TT> = <TT>$FD</TT> on demand.
</OL><HR><A NAME="tex2html137" HREF="node8.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="./next_motif.gif"></A> <A NAME="tex2html135" HREF="sidplay.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="./up_motif.gif"></A> <A NAME="tex2html129" HREF="node6.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="./previous_motif.gif"></A> <A NAME="tex2html139" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="./contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html138" HREF="node8.html">7 Acknowledgements and greetings</A>
<B>Up:</B> <A NAME="tex2html136" HREF="http://www.geocities.com/SiliconValley/Lakes/5147/index.html">SIDPLAY Home Page</A>
<B> Previous:</B> <A NAME="tex2html130" HREF="node6.html">5 Technical information</A>
</BODY>
</HTML>
